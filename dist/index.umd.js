!function(e,s){"object"==typeof exports&&"undefined"!=typeof module?s(exports):"function"==typeof define&&define.amd?define(["exports"],s):s((e="undefined"!=typeof globalThis?globalThis:e||self).store={})}(this,function(e){"use strict";class s{#e=new Map;publish(e,s){return this.#e.get(e)?.forEach(e=>e(s)),"*"!==e&&this.#e.get("*")?.forEach(e=>e(s)),this.#e.has(e)}subscribe(e,s){return this.#e.has(e)||this.#e.set(e,new Set),this.#e.get(e).add(s),()=>this.unsubscribe(e,s)}unsubscribe(e,s){if(!this.#e.has(e))return!1;const t=this.#e.get(e);let r=!0;return"function"==typeof s?(r=t.delete(s),0===t?.size&&this.#e.delete(e)):this.#e.delete(e),r}subscribeOnce(e,s){const t=r=>{s(r),this.unsubscribe(e,t)};return this.subscribe(e,t)}unsubscribeAll(e){return e?!!this.#e.has(e)&&(this.#e.delete(e),!0):(this.#e.clear(),!0)}__dump(){return Object.fromEntries(this.#e.entries())}}const t=e=>"function"==typeof e,r=(e,s="")=>{if(!t(e))throw new TypeError(`${s} Expecting function arg`.trim())},i=e=>t(e.subscribe),n=(e,i=null)=>{const n=e=>t(null==i?void 0:i.persist)&&i.persist(e);let o=new s,u=e;n(u);const c=()=>u,l=e=>{u!==e&&(u=e,n(u),o.publish("change",u))};return{set:l,get:c,update:e=>{r(e,"[update]"),l(e(c()))},subscribe:e=>(r(e,"[subscribe]"),e(u),o.subscribe("change",e))}};let o={};const u=(e,s="session")=>{if("memory"===s)return(e=>({remove:()=>{delete o[e]},set:s=>{o[e]=s},get:()=>o[e],clear:()=>{o={}},__raw:()=>o}))(e);const t="session"===s?null===globalThis||void 0===globalThis?void 0:globalThis.sessionStorage:null===globalThis||void 0===globalThis?void 0:globalThis.localStorage;return{remove:()=>null==t?void 0:t.removeItem(e),set:s=>{try{null==t||t.setItem(e,JSON.stringify(s))}catch(e){console.error(e)}},get:()=>{try{return JSON.parse(null==t?void 0:t.getItem(e))}catch(e){}},clear:()=>{try{t.clear()}catch(e){}},__raw:()=>t}};e.createDerivedStore=(e,s,o=null)=>{const u=e=>t(null==o?void 0:o.persist)&&o.persist(e),c=n(null==o?void 0:o.initialValue),l=[];if(e.forEach(e=>{if(!i(e))throw new TypeError("Expecting array of StoreLike objects");e.subscribe(e=>l.push(e))()}),!t(s))throw new TypeError("Expecting second argument to be the derivative function");if(!s.length||s.length>2)throw new TypeError("Expecting the derivative function to have exactly 1 or 2 arguments");let b=0,a=[];const h=t=>{r(t,"[derived.subscribe]"),b++||e.forEach((e,t)=>{a.push(e.subscribe(e=>{l[t]=e,1===s.length?(c.set(s(l)),u(c.get())):s(l,e=>{c.set(e),u(c.get())})}))});const i=c.subscribe(t);return()=>{--b||(a.forEach(e=>e()),a=[]),i()}};return{get:()=>{let e;return h(s=>e=s)(),e},subscribe:h}},e.createStoragePersistor=u,e.createStorageStore=(e,s="session",t)=>{["local","session","memory"].includes(s)||(console.warn(`Ignoring invalid storageType '${s}', using 'session' instead.`),s="session");const r=u(e,s);return n(r.get()||t,{persist:r.set})},e.createStore=n,e.isStoreLike=i});
