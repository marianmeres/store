"use strict";const e=e=>"function"==typeof e,t=(t,r="")=>{if(!e(t))throw new TypeError(`${r} Expecting function arg`.trim())},r=t=>e(t.subscribe),s=(r=undefined,s=null)=>{const n=t=>e(s?.persist)&&s.persist(t);let i=(()=>{const e=new Map,t=t=>(e.has(t)||e.set(t,new Set),e.get(t)),r=(e,r)=>{if("function"!=typeof r)throw new TypeError("Expecting callback function as second argument");return t(e).add(r),()=>t(e).delete(r)};return{publish:(e,r={})=>{t(e).forEach((e=>e(r)))},subscribe:r,subscribeOnce:(e,t)=>{const s=r(e,(e=>{t(e),s()}));return s},unsubscribeAll:t=>e.delete(t)}})(),c=r;n(c);const o=()=>c,u=e=>{c!==e&&(c=e,n(c),i.publish("change",c))};return{set:u,get:o,update:e=>{t(e,"[update]"),u(e(o()))},subscribe:e=>(t(e,"[subscribe]"),e(c),i.subscribe("change",e))}};exports.createDerivedStore=(n,i,c=null)=>{const o=t=>e(c?.persist)&&c.persist(t),u=s(c?.initialValue),a=[];if(n.forEach((e=>{if(!r(e))throw new TypeError("Expecting array of StoreLike objects");a.push(e.get())})),!e(i))throw new TypeError("Expecting second argument to be the derivative function");if(!i.length||i.length>2)throw new TypeError("Expecting the derivative function to have exactly 1 or 2 arguments");let b=0,p=[];return{get:u.get,subscribe:e=>{t(e,"[derived.subscribe]"),b++||n.forEach(((e,t)=>{p.push(e.subscribe((e=>{a[t]=e,1===i.length?(u.set(i(a)),o(u.get())):i(a,(e=>{u.set(e),o(u.get())}))})))}));const r=u.subscribe(e);return()=>{--b||(p.forEach((e=>e())),p=[]),r()}}}},exports.createStore=s,exports.isStoreLike=r;
