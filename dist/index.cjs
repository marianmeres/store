"use strict";class e{#e=new Map;publish(e,s){return this.#e.get(e)?.forEach(e=>e(s)),"*"!==e&&this.#e.get("*")?.forEach(e=>e(s)),this.#e.has(e)}subscribe(e,s){return this.#e.has(e)||this.#e.set(e,new Set),this.#e.get(e).add(s),()=>this.unsubscribe(e,s)}unsubscribe(e,s){if(!this.#e.has(e))return!1;const t=this.#e.get(e);let r=!0;return"function"==typeof s?(r=t.delete(s),0===t?.size&&this.#e.delete(e)):this.#e.delete(e),r}subscribeOnce(e,s){const t=r=>{s(r),this.unsubscribe(e,t)};return this.subscribe(e,t)}unsubscribeAll(e){return e?!!this.#e.has(e)&&(this.#e.delete(e),!0):(this.#e.clear(),!0)}__dump(){return Object.fromEntries(this.#e.entries())}}const s=e=>"function"==typeof e,t=(e,t="")=>{if(!s(e))throw new TypeError(`${t} Expecting function arg`.trim())},r=e=>s(e.subscribe),i=(r,i=null)=>{const n=e=>s(null==i?void 0:i.persist)&&i.persist(e);let o=new e,u=r;n(u);const c=()=>u,l=e=>{u!==e&&(u=e,n(u),o.publish("change",u))};return{set:l,get:c,update:e=>{t(e,"[update]"),l(e(c()))},subscribe:e=>(t(e,"[subscribe]"),e(u),o.subscribe("change",e))}};let n={};const o=(e,s="session")=>{if("memory"===s)return(e=>({remove:()=>{delete n[e]},set:s=>{n[e]=s},get:()=>n[e],clear:()=>{n={}},__raw:()=>n}))(e);const t="session"===s?null===globalThis||void 0===globalThis?void 0:globalThis.sessionStorage:null===globalThis||void 0===globalThis?void 0:globalThis.localStorage;return{remove:()=>null==t?void 0:t.removeItem(e),set:s=>{try{null==t||t.setItem(e,JSON.stringify(s))}catch(e){console.error(e)}},get:()=>{try{return JSON.parse(null==t?void 0:t.getItem(e))}catch(e){}},clear:()=>{try{t.clear()}catch(e){}},__raw:()=>t}};exports.createDerivedStore=(e,n,o=null)=>{const u=e=>s(null==o?void 0:o.persist)&&o.persist(e),c=i(null==o?void 0:o.initialValue),l=[];if(e.forEach(e=>{if(!r(e))throw new TypeError("Expecting array of StoreLike objects");e.subscribe(e=>l.push(e))()}),!s(n))throw new TypeError("Expecting second argument to be the derivative function");if(!n.length||n.length>2)throw new TypeError("Expecting the derivative function to have exactly 1 or 2 arguments");let b=0,a=[];const h=s=>{t(s,"[derived.subscribe]"),b++||e.forEach((e,s)=>{a.push(e.subscribe(e=>{l[s]=e,1===n.length?(c.set(n(l)),u(c.get())):n(l,e=>{c.set(e),u(c.get())})}))});const r=c.subscribe(s);return()=>{--b||(a.forEach(e=>e()),a=[]),r()}};return{get:()=>{let e;return h(s=>e=s)(),e},subscribe:h}},exports.createStoragePersistor=o,exports.createStorageStore=(e,s="session",t)=>{["local","session","memory"].includes(s)||(console.warn(`Ignoring invalid storageType '${s}', using 'session' instead.`),s="session");const r=o(e,s);return i(r.get()||t,{persist:r.set})},exports.createStore=i,exports.isStoreLike=r;
