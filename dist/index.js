class s{#s=new Map;publish(s,e){return this.#s.get(s)?.forEach(s=>s(e)),"*"!==s&&this.#s.get("*")?.forEach(s=>s(e)),this.#s.has(s)}subscribe(s,e){return this.#s.has(s)||this.#s.set(s,new Set),this.#s.get(s).add(e),()=>this.unsubscribe(s,e)}unsubscribe(s,e){if(!this.#s.has(s))return!1;const t=this.#s.get(s);let r=!0;return"function"==typeof e?(r=t.delete(e),0===t?.size&&this.#s.delete(s)):this.#s.delete(s),r}subscribeOnce(s,e){const t=r=>{e(r),this.unsubscribe(s,t)};return this.subscribe(s,t)}unsubscribeAll(s){return s?!!this.#s.has(s)&&(this.#s.delete(s),!0):(this.#s.clear(),!0)}__dump(){return Object.fromEntries(this.#s.entries())}}const e=s=>"function"==typeof s,t=(s,t="")=>{if(!e(s))throw new TypeError(`${t} Expecting function arg`.trim())},r=s=>e(s.subscribe),i=(r,i=null)=>{const n=s=>e(null==i?void 0:i.persist)&&i.persist(s);let o=new s,u=r;n(u);const l=()=>u,c=s=>{u!==s&&(u=s,n(u),o.publish("change",u))};return{set:c,get:l,update:s=>{t(s,"[update]"),c(s(l()))},subscribe:s=>(t(s,"[subscribe]"),s(u),o.subscribe("change",s))}},n=(s,n,o=null)=>{const u=s=>e(null==o?void 0:o.persist)&&o.persist(s),l=i(null==o?void 0:o.initialValue),c=[];if(s.forEach(s=>{if(!r(s))throw new TypeError("Expecting array of StoreLike objects");s.subscribe(s=>c.push(s))()}),!e(n))throw new TypeError("Expecting second argument to be the derivative function");if(!n.length||n.length>2)throw new TypeError("Expecting the derivative function to have exactly 1 or 2 arguments");let b=0,a=[];const h=e=>{t(e,"[derived.subscribe]"),b++||s.forEach((s,e)=>{a.push(s.subscribe(s=>{c[e]=s,1===n.length?(l.set(n(c)),u(l.get())):n(c,s=>{l.set(s),u(l.get())})}))});const r=l.subscribe(e);return()=>{--b||(a.forEach(s=>s()),a=[]),r()}};return{get:()=>{let s;return h(e=>s=e)(),s},subscribe:h}};let o={};const u=(s,e="session")=>{if("memory"===e)return(s=>({remove:()=>{delete o[s]},set:e=>{o[s]=e},get:()=>o[s],clear:()=>{o={}},__raw:()=>o}))(s);const t="session"===e?null===globalThis||void 0===globalThis?void 0:globalThis.sessionStorage:null===globalThis||void 0===globalThis?void 0:globalThis.localStorage;return{remove:()=>null==t?void 0:t.removeItem(s),set:e=>{try{null==t||t.setItem(s,JSON.stringify(e))}catch(s){console.error(s)}},get:()=>{try{return JSON.parse(null==t?void 0:t.getItem(s))}catch(s){}},clear:()=>{try{t.clear()}catch(s){}},__raw:()=>t}},l=(s,e="session",t)=>{["local","session","memory"].includes(e)||(console.warn(`Ignoring invalid storageType '${e}', using 'session' instead.`),e="session");const r=u(s,e);return i(r.get()||t,{persist:r.set})};export{n as createDerivedStore,u as createStoragePersistor,l as createStorageStore,i as createStore,r as isStoreLike};
