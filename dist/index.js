const e=e=>"function"==typeof e,t=(t,s="")=>{if(!e(t))throw new TypeError(`${s} Expecting function arg`.trim())},s=t=>e(t.subscribe),r=(s,r=null)=>{const n=t=>e(r?.persist)&&r.persist(t);let o=(()=>{const e=new Map,t=t=>(e.has(t)||e.set(t,new Set),e.get(t)),s=(e,s)=>{if("function"!=typeof s)throw new TypeError("Expecting callback function as second argument");return t(e).add(s),()=>t(e).delete(s)};return{publish:(e,s)=>{t(e).forEach((e=>e(s)))},subscribe:s,subscribeOnce:(e,t)=>{const r=s(e,(e=>{t(e),r()}));return r},unsubscribeAll:t=>e.delete(t)}})(),i=s;n(i);const c=()=>i,u=e=>{i!==e&&(i=e,n(i),o.publish("change",i))};return{set:u,get:c,update:e=>{t(e,"[update]"),u(e(c()))},subscribe:e=>(t(e,"[subscribe]"),e(i),o.subscribe("change",e))}},n=(n,o,i=null)=>{const c=t=>e(i?.persist)&&i.persist(t),u=r(i?.initialValue),a=[];if(n.forEach((e=>{if(!s(e))throw new TypeError("Expecting array of StoreLike objects");e.subscribe((e=>a.push(e)))()})),!e(o))throw new TypeError("Expecting second argument to be the derivative function");if(!o.length||o.length>2)throw new TypeError("Expecting the derivative function to have exactly 1 or 2 arguments");let b=0,g=[];const l=e=>{t(e,"[derived.subscribe]"),b++||n.forEach(((e,t)=>{g.push(e.subscribe((e=>{a[t]=e,1===o.length?(u.set(o(a)),c(u.get())):o(a,(e=>{u.set(e),c(u.get())}))})))}));const s=u.subscribe(e);return()=>{--b||(g.forEach((e=>e())),g=[]),s()}};return{get:()=>{let e;return l((t=>e=t))(),e},subscribe:l}},o=(e,t="session")=>{const s="session"===t?window?.sessionStorage:window?.localStorage;return{remove:()=>s?.removeItem(e),set:t=>{try{s?.setItem(e,JSON.stringify(t))}catch(e){console.error(e)}},get:()=>{try{return JSON.parse(s?.getItem(e))}catch(e){}}}},i=(e,t="session",s)=>{["local","session"].includes(t)||(console.warn(`Ignoring invalid storageType '${t}', using 'session' instead.`),t="session");const n=o(e,t);return r(n.get()||s,{persist:n.set})};export{n as createDerivedStore,o as createStoragePersistor,i as createStorageStore,r as createStore,s as isStoreLike};
